<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Transformations  - OpenTK</title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Transformations ">
    <meta name="generator" content="docfx 2.56.6.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  
    <meta name="author" content="The Open Toolkit Project">
    <meta property="og:image" content="https://opentk.net/otkBig.png">
    <meta property="og:image:width" content="142">
    <meta property="og:image:height" content="50">
    <meta property="og:site_name" content="OpenTK">
    <meta property="og:title" content="Transformations  - OpenTK">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation" style="background: #0052cc;">
          <div class="container">
            <a class="navbar-brand" href="../../index.html">
          <img id="logo" src="../../otkBig.png" alt="">
        </a>
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="transformations">Transformations</h1>

<p>We now know how to create objects, color them and/or give them a detailed appearance using textures, but they're still not that interesting since they're all static objects. We could try and make them move by changing their vertices and re-configuring their buffers each frame, but that's cumbersome and costs quite some processing power. There are much better ways to transform an object and that's by using (multiple) matrix objects. This doesn't mean we're going to talk about kungfu and a large digital artificial world.</p>
<p>Matrices are very powerful mathematical constructs that seem scary at first, but once you'll grow accustomed to them they'll prove extremely useful. When discussing matrices, we'll have to make a small dive into some mathematics and for the more mathematically inclined readers I'll post additional resources for further reading.</p>
<p>However, to fully understand transformations we first have to delve a bit deeper into vectors before discussing matrices. The focus of this chapter is to give you a basic mathematical background in topics we will require later on. If the subjects are difficult, try to understand them as much as you can and come back to this page later to review the concepts whenever you need them.</p>
<h2 id="vectors">Vectors</h2>
<p>In its most basic definition, vectors are directions and nothing more. A vector has a direction and a magnitude (also known as its strength or length). You can think of vectors like directions on a treasure map: 'go left 10 steps, now go north 3 steps and go right 5 steps'; here 'left' is the direction and '10 steps' is the magnitude of the vector. The directions for the treasure map thus contains 3 vectors. Vectors can have any dimension, but we usually work with dimensions of 2 to 4. If a vector has 2 dimensions it represents a direction on a plane (think of 2D graphs) and when it has 3 dimensions it can represent any direction in a 3D world.</p>
<p>Below you'll see 3 vectors where each vector is represented with (x,y) as arrows in a 2D graph. Because it is more intuitive to display vectors in 2D (than in 3D) you can think of the 2D vectors as 3D vectors with a z coordinate of 0. Since vectors represent directions, the origin of the vector does not change its value. In the graph below we can see that the vectors <strong>v</strong>
and <strong>w</strong> are equal even though their origin is different:</p>
<p><img src="img/7-vectors.png" alt="Vectors"></p>
<p>When describing vectors mathematicians generally prefer to describe vectors as character symbols with a little bar over their head. However, we can't do that in Markdown, so we'll bold vector names instead, like <strong>v</strong>. Also, when displaying vectors in formulas they are generally displayed as follows:</p>
<p><img src="img/7-latex_vector.png" alt="How vectors are displayed in formulas"></p>
<p>Because vectors are specified as directions it is sometimes hard to visualize them as positions. What we basically visualize is we set the origin of the direction to <strong>(0,0,0)</strong> and then point towards a certain direction that specifies the point, making it a position vector (we could also specify a different origin and then say: 'this vector points to that point in space from this origin'). The position vector <strong>(3,5)</strong> would then point to <strong>(3,5)</strong> on the graph with an origin of <strong>(0,0)</strong>. Using vectors we can thus describe directions and positions in 2D and 3D space.</p>
<p>Just like with normal numbers we can also define several operations on vectors (some of which you've already seen).</p>
<h2 id="scalar-vector-operations">Scalar vector operations</h2>
<p>A scalar is a single digit (or a vector with 1 component if you'd like stay in vector-land). When adding/subtracting/multiplying or dividing a vector with a scalar we simply add/subtract/multiply or divide each element of the vector by the scalar. For addition it would look like this:</p>
<p><img src="img/7-latex_scalar_addition.png" alt="Scalar vector operations"></p>
<p>Where <strong>+</strong> can be <strong>+</strong>,<strong>-</strong>, <strong>•</strong> or <strong>÷</strong> where <strong>•</strong> is the multiplication operator. Keep in mind that for the <strong>-</strong> and <strong>÷</strong> operator order, the reverse order is not defined.</p>
<h2 id="vector-negation">Vector negation</h2>
<p>Negating a vector results in a vector in the reversed direction. A vector pointing north-east would point south-west after negation. To negate a vector we add a minus-sign to each component (you can also represent it as a scalar-vector multiplication with a scalar value of -1):</p>
<p><img src="img/7-latex_vector_negation.png" alt="Vector negation"></p>
<h2 id="addition-and-subtraction">Addition and subtraction</h2>
<p>Addition of two vectors is defined as component-wise addition, that is each component of one vector is added to the same component of the other vector like so:</p>
<p><img src="img/7-latex_vector_addition.png" alt="Vector addition"></p>
<p>Visually, it looks like this on vectors <strong>v=(4,2)</strong> and <strong>k=(1,2)</strong>:</p>
<p><img src="img/7-vector_addition.png" alt="Addition of vectors"></p>
<p>Just like normal addition and subtraction, vector subtraction is the same as addition with a negated second vector:</p>
<p><img src="img/7-latex_vector_subtraction.png" alt="Vector subtraction"></p>
<p>Subtracting two vectors from each other results in a vector that's the difference of the positions both vectors are pointing at. This proves useful in certain cases where we need to retrieve a vector that's the difference between two points.</p>
<p><img src="img/7-vector_subtraction.png" alt="Subtraction of vectors"></p>
<h2 id="length">Length</h2>
<p>To retrieve the length/magnitude of a vector we use the Pythagoras theorem that you might remember from your math classes. A vector forms a triangle when you visualize its individual <strong>x</strong> and <strong>y</strong> component as two sides of a triangle:</p>
<p><img src="img/7-vector_triangle.png" alt="Pythagoras theorem"></p>
<p><img src="img/7-latex_pythagoras_theorem.png" alt="Pythagoras theorem formula"></p>
<p>Where <strong>||v||</strong> is denoted as <em>the length of vector</em> <strong>v</strong>. This is easily extended to 3D by adding <strong>z^2</strong> to the equation.</p>
<p>In this case the length of vector <strong>(4, 2)</strong> equals:</p>
<p><img src="img/7-latex_pythagoras_theorem_demonstrated.png" alt="Pythagoras theorem formula demonstration"></p>
<p>Which is <strong>4.47</strong>.</p>
<p>There is also a special type of vector that we call a <em>unit vector</em>. A unit vector has one extra property and that is that its length is exactly 1. We can calculate a unit vector <strong>n</strong> from any vector by dividing each of the vector's components by its length:</p>
<p><img src="img/7-latex_unit_vector.png" alt="Unit vector"></p>
<p>We call this <em>normalizing</em> a vector. Unit vectors are displayed with a little roof over their head and are generally easier to work with, especially when we only care about their directions (the direction does not change if we change a vector's length).</p>
<h2 id="vector-vector-multiplication">Vector-vector multiplication</h2>
<p>Multiplying two vectors is a bit of a weird case. Normal multiplication isn't really defined on vectors since it has no visual meaning, but we have two specific cases that we could choose from when multiplying: one is the <em>dot product</em> denoted as <strong>v</strong> • <strong>k</strong> and the other is the <em>cross product</em> denoted as <strong>v</strong> × <strong>k</strong>.</p>
<h3 id="dot-product">Dot product</h3>
<p>The dot product of two vectors is equal to the scalar product of their lengths times the cosine of the angle between them. If this sounds confusing take a look at its formula:</p>
<p><img src="img/7-latex_dot_product.png" alt="Dot product formula"></p>
<p>Where the angle between them is represented as theta (θ). Why is this interesting? Well, imagine if <strong>v</strong> and <strong>k</strong> are unit vectors then their length would be equal to 1. This would effectively reduce the formula to:</p>
<p><img src="img/7-latex_dot_product_simplified.png" alt="Dot product formula, simplified"></p>
<p>Now the dot product <strong>only</strong> defines the angle between both vectors. You might remember that the cosine or cos function becomes <strong>0</strong> when the angle is 90 degrees or <strong>1</strong> when the angle is 0. This allows us to easily test if the two vectors are <em>orthogonal</em> or parallel to each other using the dot product (orthogonal means the vectors are at a <em>right-angle</em> to each other). In case you want to know more about the <strong>sin</strong> or the <strong>cosine</strong> functions I'd suggest the following <a href="https://www.khanacademy.org/math/trigonometry/basic-trigonometry/basic_trig_ratios/v/basic-trigonometry">Khan Academy videos</a> about basic trigonometry.</p>
<blockquote>
<p>You can also calculate the angle between two non-unit vectors, but then you'd have to divide the lengths of both vectors from the result to be left with <strong>cos θ</strong>.</p>
</blockquote>
<p>So how do we calculate the dot product? The dot product is a component-wise multiplication where we add the results together. It looks like this with two unit vectors (you can verify that both their lengths are exactly <strong>1</strong>):</p>
<p><img src="img/7-latex_dot_product_vectors.png" alt="Dot product demonstrated with two vectors"></p>
<p>To calculate the degree between both these unit vectors we use the inverse of the cosine function <strong>cos^-1</strong>, and this results in <strong>143.1</strong> degrees. We now effectively calculated the angle between these two vectors. The dot product proves very useful when doing lighting calculations.</p>
<h2 id="cross-product">Cross product</h2>
<p>The cross product is only defined in 3D space and takes two non-parallel vectors as input and produces a third vector that is orthogonal to both the input vectors. If both the input vectors are orthogonal to each other as well, a cross product would result in 3 orthogonal vectors. This will prove useful in the upcoming tutorials. The following image shows what this looks like in 3D space:</p>
<p><img src="img/7-vector_crossproduct.png" alt="Cross product of two vectors"></p>
<p>Unlike the other operations, the cross product isn't really intuitive without delving into linear algebra so it's best to just memorize the formula and you'll be fine (or don't, you'll probably be fine as well). Below you'll see the cross product between two orthogonal vectors A and B:</p>
<p><img src="img/7-latex_cross_product.png" alt="Cross product formula"></p>
<p>As you can see, it doesn't really seem to make sense. However, if you just follow these steps you'll get another vector that is orthogonal to your input vectors.</p>
<h2 id="matrices">Matrices</h2>
<p>Now that we've discussed almost all there is to vectors it is time to enter the matrix! A matrix is basically a rectangular array of numbers, symbols and/or expressions. Each individual item in a matrix is called an element of the matrix. An example of a 2x3 matrix is shown below:</p>
<p><img src="img/7-latex_matrix.png" alt="2x3 Matrix"></p>
<p>Matrices are indexed by <strong>(i,j)</strong> where <strong>i</strong> is the row and <strong>j</strong> is the column, that is why the above matrix is called a 2x3 matrix (3 columns and 2 rows, also known as the dimensions of the matrix). This is the opposite of what you're used to when indexing 2D graphs as <strong>(x,y)</strong>. To retrieve the value 4 we would index it as (2,1) (second row, first column).</p>
<blockquote>
<p>It is important to note that OpenTK stores its matrices in column-major form, <strong>not</strong> row-major form. This doesn't have a major impact on most matrix operations, but I'll be sure to point out whenever it has an effect.</p>
</blockquote>
<p>Matrices are basically nothing more than that, just rectangular arrays of mathematical expressions. They do have a very nice set of mathematical properties and just like vectors we can define several operations on matrices, namely: addition, subtraction and multiplication.</p>
<h2 id="matrix-addition-and-subtraction">Matrix addition and subtraction</h2>
<p>Addition and subtraction between a matrix and a scalar is defined as follows:</p>
<p><img src="img/7-latex_matrix_addition_scalar.png" alt="Matrix addition with a scalar"></p>
<p>The scalar value is basically added to each individual element of the matrix. The same applies for matrix-scalar subtraction:</p>
<p><img src="img/7-latex_matrix_subtraction_scalar.png" alt="Matrix subtraction with a scalar"></p>
<p>Matrix addition and subtraction between two matrices is done on a per-element basis. So the same general rules apply that we're familiar with for normal numbers, but done on the elements of both matrices with the same index. This does mean that addition and subtraction is only defined for matrices of the same dimensions. A 3x2 matrix and a 2x3 matrix (or a 3x3 matrix and a 4x4 matrix) cannot be added or subtracted together. Let's see how matrix addition works on two 2x2 matrices:</p>
<p><img src="img/7-latex_matrix_addition_matrix.png" alt="Matrix addition with a matrix"></p>
<p>The same rules apply for matrix subtraction:</p>
<p><img src="img/7-latex_matrix_subtraction_matrix.png" alt="Matrix subtraction with a matrix"></p>
<h2 id="matrix-scalar-products">Matrix-scalar products</h2>
<p>Just like addition and subtraction, a matrix-scalar product multiples each element of the matrix by a scalar. The following example illustrates the multiplication:</p>
<p><img src="img/7-latex_matrix_product_scalar.png" alt="Matrix product with a scalar"></p>
<p>Now it also makes sense as to why those single numbers are called scalars. A scalar basically scales all the elements of the matrix by its value. In the previous example, all elements were scaled by 2.</p>
<p>So far so good, all of our cases weren't really too complicated. That is, until we start on matrix-matrix multiplication.</p>
<h2 id="matrix-matrix-multiplication">Matrix-matrix multiplication</h2>
<p>Multiplying matrices is not necessarily complex, but rather difficult to get comfortable with. Matrix multiplication basically means to follow a set of pre-defined rules when multiplying. There are a few restrictions though:</p>
<ol>
<li>You can only multiply two matrices if the number of columns on the left-hand side matrix is equal to the number of rows on the right-hand side matrix.</li>
<li>Matrix multiplication is not commutative. That is, A • B does not equal B • A.</li>
</ol>
<p>Let's get started with an example of a matrix multiplication of two 2x2 matrices:</p>
<p><img src="img/7-latex_matrix_product_matrix.png" alt="Matrix product with a matrix"></p>
<p>Right now you're probably trying to figure out what the hell just happened? Matrix multiplication is a combination of normal multiplication and addition using the left-matrix's rows with the right-matrix's columns. Let's try discussing this with the following image:</p>
<p><img src="img/7-matrix_multiplication.png" alt="Matrix multiplication"></p>
<p>We first take the upper row of the left matrix and then take a column from the right matrix. The row and column that we picked decides which output value of the resulting 2x2 matrix we're going to calculate. If we take the first row of the left matrix the resulting value will end up in the first row of the result matrix, then we pick a column and if it's the first column the result value will end up in the first column of the result matrix. This is exactly the case of the red pathway. To calculate the bottom-right result we take the bottom row of the first matrix and the rightmost column of the second matrix.</p>
<p>To calculate the resulting value we multiply the first element of the row and column together using normal multiplication, we do the same for the second elements, third, fourth etc. The results of the individual multiplications are then summed up and we have our result. Now it also makes sense that one of the requirements is that the size of the left-matrix's columns and the right-matrix's rows are equal, otherwise we can't finish the operations!</p>
<p>The result is then a matrix that has dimensions of <strong>(n,m)</strong> where n is equal to the number of rows of the left-hand side matrix and m is equal to the columns of the right-hand side matrix.</p>
<p>Don't worry if you have difficulties imagining the multiplications inside your head. Just keep trying to do the calculations by hand and return to this page whenever you have difficulties. Over time, matrix multiplication becomes second nature to you.</p>
<p>Let's finish the discussion of matrix-matrix multiplication with a larger example. Try to visualize the pattern using the colors. As a useful exercise, see if you can come up with your own answer of the multiplication and then compare them with the resulting matrix (once you try to do a matrix multiplication by hand you'll quickly get the grasp of them).</p>
<p><img src="img/7-latex_matrix_product_matrix_bigger.png" alt="Matrix multiplication, on a bigger scale"></p>
<p>As you can see, matrix-matrix multiplication is quite a cumbersome process and very prone to errors (which is why we usually let computers do this) and this gets problematic real quick when the matrices become larger. If you're still thirsty for more and you're curious about some more of the mathematical properties of matrices I strongly suggest you take a look at these <a href="https://www.khanacademy.org/math/algebra2/algebra-matrices">Khan Academy videos</a> about matrices.</p>
<p>Anyways, now that we know how to multiply matrices together, we can start getting to the good stuff.</p>
<h2 id="matrix-vector-multiplication">Matrix-Vector multiplication</h2>
<p>Up until now we've had our fair share of vectors these tutorials. We used vectors to represent positions, colors and even texture coordinates. Let's move a bit further down the rabbit hole and tell you that a vector is basically a Nx1 matrix where N is the vector's number of components (also known as an N-dimensional vector). If you think about it, it makes a lot of sense. Vectors are just like matrices an array of numbers, but with only 1 column. So, how does this new piece of information help us? Well, if we have a MxN matrix we can multiply this matrix by our Nx1 vector, since the columns of our matrix are equal to the number of rows of our vector, thus matrix multiplication is defined.</p>
<p>But why do we care if we can multiply matrices with a vector? Well, it just so happens that there are lots of interesting 2D/3D transformations we can place inside a matrix and multiplying that matrix with our vector basically transforms our vector. In case you're still a bit confused, let's start with some examples and you'll soon see what we mean.</p>
<h3 id="identity-matrix">Identity matrix</h3>
<p>In OpenGL we usually work with 4x4 transformation matrices for several reasons and one of them is that most of the vectors are of size 4. The most simple transformation matrix that we can think of is the identity matrix. The identity matrix is an NxN matrix with only 0s except on its diagonal. As you'll see, this transformation matrix leaves a vector completely unharmed:</p>
<p><img src="img/7-latex_matrix_identity.png" alt="The identity matrix"></p>
<p>The vector seems completely untouched. This becomes obvious from the rules of multiplication: the first result element is each individual element of the first row of the matrix multiplied with each element of the vector. Since each of the row's elements are 0 except the first one, we get: <code>1 • 1 + 0 • 2 + 0 • 3 + 0 • 4 = 1</code> and the same applies for the other 3 elements of the vector.</p>
<blockquote>
<p>You might be wondering what the use is of a transformation matrix that does not transform? The identity matrix is usually a starting point for generating other transformation matrices and if we dig even deeper into linear algebra, a very useful matrix for proving theorems and solving linear equations.</p>
</blockquote>
<h3 id="scaling">Scaling</h3>
<p>When we're scaling a vector we are increasing the length of the arrow by amount we'd like to scale, keeping its direction the same. Since we're working in either 2 or 3 dimensions we can define scaling by a vector of 2 or 3 scaling variables, each scaling one axis (x, y or z).</p>
<p>Let's try scaling the vector <strong>v</strong> = (3,2). We will scale the vector along the x-axis by <strong>0.5</strong>, thus making it twice as narrow; and we'll scale the vector by <strong>2</strong> along the y-axis, making it twice as high. Let's see what it looks like if we scale the vector by <strong>(0.5,2)</strong> as <strong>s</strong>:</p>
<p><img src="img/7-vector_scale.png" alt="Scaling vectors"></p>
<p>Keep in mind that OpenGL usually operates in 3D space so for this 2D case we could set the z-axis scale to 1 thus leaving it unharmed. The scaling operation we just performed is a non-uniform scale, because the scaling factor is not the same for each axis. If the scalar would be equal on all axes it would be called a uniform scale.</p>
<p>Let's start building a transformation matrix that does the scaling for us. We saw from the identity matrix that each of the diagonal elements were multiplied with its corresponding vector element. What if we were to change the <strong>1</strong>s in the identity matrix to <strong>3</strong>s? In that case, we would be multiplying each of the vector elements by a value of <strong>3</strong> and thus effectively scale the vector by 3. If we represent the scaling variables as (S1, S2, S3) we can define a scaling matrix on any vector <strong>(x,y,z)</strong> as:</p>
<p><img src="img/7-latex_matrix_scale.png" alt="Scaling matrix"></p>
<p>Note that the 4th scaling vector stays 1, since it's undefined to scale the <strong>w</strong> component in a 3D space. The <strong>w</strong> component is used for other purposes as we'll see later on.</p>
<h3 id="translation">Translation</h3>
<p><em>Translation</em> is the process of adding another vector on top of the original vector to return a new vector with a different position, thus moving the vector based on a translation vector. We've already discussed vector addition so this shouldn't be too new.</p>
<p>Just like the scaling matrix there are several locations on a 4-by-4 matrix that we can use to perform certain operations and for translation those are the top-3 values of the 4th column. If we represent the translation vector as (Tx, Ty, Tz) we can define the translation matrix by:</p>
<p><img src="img/7-latex_matrix_translation.png" alt="Translation matrix"></p>
<p>This works because all of the translation values are multiplied by the vector's <strong>w</strong> column and added to the vector's original values (remember the matrix-multiplication rules). This wouldn't have been possible with a 3-by-3 matrix.</p>
<blockquote>
<h3 id="homogeneous-coordinates">Homogeneous coordinates</h3>
<p>The <strong>w</strong> component of a vector is also known as a <em>homogeneous coordinate</em>.
To get the 3D vector from a homogeneous vector we divide the <strong>x</strong>, <strong>y</strong> and <strong>z</strong> coordinate by its <strong>w</strong> coordinate. We usually do not notice this since the <strong>w</strong> component is <strong>1.0</strong> most of the time. Using homogeneous coordinates has several advantages: it allows us to do translations on 3D vectors (without a <strong>w</strong> component we can't translate vectors) and in the next chapter we'll use the <strong>w</strong> value to create 3D visuals.
Also, whenever the homogeneous coordinate is equal to <strong>0</strong> the vector is specifically known as a <em>direction vector</em> since a vector with a <strong>w</strong> coordinate of <strong>0</strong> cannot be translated.</p>
</blockquote>
<p>With a translation matrix we could move objects in any of the 3 directions (<strong>x</strong>, <strong>y</strong>, <strong>z</strong>) we'd like, making it a very useful transformation matrix for our transformation toolkit.</p>
<h3 id="rotation">Rotation</h3>
<p>The last few transformations were relatively easy to understand and visualize in 2D or 3D space, but rotations are a bit trickier. If you want to know exactly how these matrices are constructed I'd recommend that you watch the rotation items of Khan Academy's <a href="https://www.khanacademy.org/math/linear-algebra/matrix_transformations">linear algebra videos</a>.</p>
<p>First let's define what a rotation of a vector actually is. A rotation in 2D or 3D is represented with an angle. An angle could be in degrees or radians where a whole circle has 360 degrees or 2 PI radians. I personally prefer to work in degrees, since they seem to make more sense to me.</p>
<blockquote>
<p>Most rotation functions require an angle in radians, but luckily degrees are easily converted to radians:
angle in degrees = angle in radians * (180.0f / PI)
angle in radians = angle in degrees * (PI / 180.0f)
Where PI equals (sort of) 3.14159265359.
In addition, OpenTK provides the function <code>MathHelper.DegreesToRadians</code> to easily convert to radians.</p>
</blockquote>
<p>Rotating half a circle would rotate us 360/2 = 180 degrees and rotating 1/5th to the right means we rotate 360/5 = 72 degrees to the right. This is demonstrated for a basic 2D vector where <strong>v</strong> is rotated 72 degrees to the right from <strong>k</strong>:</p>
<p><img src="img/7-vector_angle.png" alt="Vector angles"></p>
<p>Rotations in 3D are specified with an angle and a rotation axis. The angle specified will rotate the object along the rotation axis given. Try to visualize this by spinning your head a certain degree while continually looking down a single rotation axis. When rotating 2D vectors in a 3D world for example, we set the rotation axis to the z-axis (try to visualize this).</p>
<p>Using trigonometry it is possible to transform vectors to new rotated vectors given an angle. This is usually done via a smart combination of the sine and cosine function (commonly abbreviated to <strong>sin</strong> and <strong>cos</strong>). A discussion of how the transformation matrices are generated is out of the scope of this tutorial.</p>
<p>A rotation matrix is defined for each unit axis in 3D space where the angle is represented as the theta symbol θ.</p>
<p>Rotation around the X-axis:</p>
<p><img src="img/7-latex_matrix_rotation_x.png" alt="A rotation matrix on the X axis"></p>
<p>Rotation around the Y-axis:</p>
<p><img src="img/7-latex_matrix_rotation_y.png" alt="A rotation matrix on the Y axis"></p>
<p>Rotation around the Z-axis:</p>
<p><img src="img/7-latex_matrix_rotation_z.png" alt="A rotation matrix on the z axis"></p>
<p>Using the rotation matrices we can transform our position vectors around one of the three unit axes. It is also possible to combine them by first rotating around the X-axis and then the Y-axis for example. However, this quickly introduces a problem called <em>Gimbal lock</em>. We won't discuss the details, but a better solution is to rotate around an arbitrary unit axis e.g. <strong>(0.662,0.2,0.722)</strong> (note that this is a unit vector) right away instead of combining the rotation matrices. Such a (nasty) matrix exists and is given below with (Rx, Ry, Rz) as the arbitrary rotation axis:</p>
<p><img src="img/7-latex_matrix_rotation_all.png" alt="A rotation matrix on all axes"></p>
<p>A mathematical discussion of generating such a matrix is out of the scope of this tutorial. Keep in mind that even this matrix does not completely prevent gimbal lock (although it gets a lot harder). To truly prevent Gimbal locks we have to represent rotations using <em>quaternions</em>, that are not only safer, but also more computationally friendly. However, a discussion of quaternions is reserved for a later tutorial.</p>
<h3 id="combining-matrices">Combining matrices</h3>
<p>The true power from using matrices for transformations is that we can combine multiple transformations in a single matrix thanks to matrix-matrix multiplication. Let's see if we can generate a transformation matrix that combines several transformations. Say we have a vector (x,y,z) and we want to scale it by 2 and then translate it by (1,2,3). We need a translation and a scaling matrix for our required steps. The resulting transformation matrix would then look like:</p>
<p><img src="img/7-latex_combining_matrices.png" alt="Combining matrices"></p>
<p>Note that we first do a translation and then a scale transformation when multiplying matrices. Matrix multiplication is not commutative, which means their order is important. When multiplying matrices the right-most matrix is first multiplied with the vector so you should read the multiplications from right to left. It is advised to first do scaling operations, then rotations and lastly translations when combining matrices otherwise they might (negatively) affect each other. For example, if you would first do a translation and then scale, the translation vector would also scale!</p>
<p>Running the final transformation matrix on our vector results in the following vector:</p>
<p><img src="img/7-latex_combining_matrices_result.png" alt="Combining matrices final"></p>
<p>Great! The vector is first scaled by two and then translated by <strong>(1,2,3)</strong>.</p>
<h2 id="in-practice">In practice</h2>
<p>OpenTK provides its own mathematics library, so there's no need to add another one. Let's see if we can put our transformation knowledge to good use by translating a vector of <strong>(1,0,0)</strong> by <strong>(1,1,0)</strong> (note that we define it as a Vector4 with its homogenous coordinate set to 1.0:</p>
<pre><code class="lang-cs">Vector4 vec = new Vector4(1.0f, 0.0f, 0.0f, 1.0f);
Matrix4 trans = Matrix4.CreateTranslation(0.1f, 0.1f, 0.0f);
vec *= trans;
Console.WriteLine(&quot;{0}, {1}, {2}&quot;, vec.x, vec.y, vec.z);
</code></pre>
<p>We first define a vector named vec using OpenTK's built-in vector class. Next we define a Matrix4 and explicitly initialize it to the identity matrix by calling the <code>Matrix4.CreateTranslation</code> function, which takes three floats and creates a translation matrix.</p>
<p>Then we multiply our vector by the transformation matrix and output the result. If we still remember how matrix translation works then the resulting vector should be <strong>(1+1,0+1,0+0)</strong> which is <strong>(2,1,0)</strong>. This snippet of code outputs 210 so the translation matrix did its job.</p>
<p>Let's do something more interesting and scale and rotate the container object from the previous tutorial:</p>
<pre><code class="lang-cs">Matrix4 rotation = Matrix4.CreateRotationZ(MathHelper.DegreesToRadians(90.0f));
Matrix4 scale = Matrix4.CreateScale(0.5f, 0.5f, 0.5f);
Matrix4 trans = rotation * scale;
</code></pre>
<p>We create two matrices: one to rotate 90 degrees on the Z axis, and the other to scale on all axes by 0.5. OpenTK expects its angles in radians so we convert the degrees to radians using <code>MathHelper.DegreesToRadians</code>. Note that the textured rectangle is on the XY plane so we want to rotate around the Z-axis. Keep in mind that the axis that we rotate around should be a unit vector, so be sure to normalize the vector first if you're not rotating around the X, Y, or Z axis. Then, we multiply the matrices together to create a single transformation matrix.</p>
<p>The next big question is: how do we get the transformation matrix to the shaders? We shortly mentioned before that GLSL also has a mat4 type. So we'll adapt the vertex shader to accept a mat4 uniform variable and multiply the position vector by the matrix uniform:</p>
<pre><code class="lang-glsl">#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;
  
uniform mat4 transform;

void main()
{
    gl_Position = vec4(aPos, 1.0f) * transform;
    TexCoord = vec2(aTexCoord.x, aTexCoord.y);
}
</code></pre>
<blockquote>
<p>GLSL also has mat2 and mat3 types that allow for swizzling-like operations just like vectors. All the aforementioned math operations (like scalar-matrix multiplication, matrix-vector multiplication and matrix-matrix multiplication) are allowed on the matrix types. Wherever special matrix operations are used we'll be sure to explain what's happening.</p>
</blockquote>
<p>We added the uniform and multiplied the position vector with the transformation matrix before passing it to gl_Position. Our container should now be half its size and rotated 90 degrees on the Z axis (tilted to the left). We still need to pass the transformation matrix to the shader though:</p>
<pre><code class="lang-cs">GL.UseProgram(program);

int location = GL.GetUniformLocation(Handle, name);

GL.UniformMatrix4(location, true, ref matrix);
</code></pre>
<p><code>GL.UniformMatrix4</code> is a fairly standard function, similar to the other Uniform functions we've seen so far. The parameters are as follows:</p>
<ul>
<li>The location of the uniform on the shader.</li>
<li>A boolean, determining whether or not the matrices should be transposed. Since OpenTK uses row-major, whereas GLSL typically uses column-major, you'll almost always want to use <code>true</code> here.</li>
<li>A reference to the matrix we want to pass.</li>
</ul>
<p>We created a transformation matrix, declared a uniform in the vertex shader and sent the matrix to the shaders where we transform our vertex coordinates. The result should look something like this:</p>
<p><img src="img/7-transformations.png" alt="Transformation result"></p>
<p>Perfect! Our container is indeed tilted to the left and twice as small so the transformation was successful.</p>
<p>If you didn't get the right result or you're stuck somewhere else, take a look at the source code and the updated shader class.</p>
<p>In the next tutorial we'll discuss how we can use matrices to define different coordinate spaces for our vertices. This will be our first step into real-time 3D graphics!</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
